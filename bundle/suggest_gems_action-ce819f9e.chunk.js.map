{"version":3,"file":"suggest_gems_action-ce819f9e.chunk.js","sources":["../../../ui/core/components/suggest_gems_action.ts"],"sourcesContent":["import { IndividualSimUI } from '../individual_sim_ui.js';\nimport { Player } from '../player.js';\nimport { Sim } from '../sim.js';\nimport { Gear } from '../proto_utils/gear.js';\nimport { EquippedItem } from '../proto_utils/equipped_item.js';\nimport { TypedEvent } from '../typed_event.js';\nimport { Stats } from '../proto_utils/stats.js';\nimport { GemColor, Stat, Profession, ItemSlot, Spec } from '../proto/common.js';\n\ninterface GemCapsData {\n\tgemId: number\n\tstatCaps: Stats\n}\n\ninterface SocketData {\n\titemSlot: ItemSlot\n\tsocketIdx: number\n}\n\nabstract class GemOptimizer {\n\tprotected readonly player: Player<Spec>;\n\tprotected readonly sim: Sim;\n\tprotected readonly gemPriorityByColor: Record<GemColor, Array<GemCapsData>>; \n\tabstract metaGemID: number;\t\n\tstatic allGemColors: Array<GemColor> = [GemColor.GemColorRed, GemColor.GemColorYellow, GemColor.GemColorBlue];\n\tepWeights!: Stats;\n\tuseJcGems!: boolean;\n\tisBlacksmithing!: boolean;\n\tnumSocketedJcGems!: number;\n\tjcUpgradePriority: Array<GemCapsData>;\n\n\tstatic jcUpgradesById: Record<number, number> = {\n\t\t40118: 42154,\n\t\t40125: 42156,\n\t\t40112: 42143,\n\t\t40111: 42142,\n\t\t40119: 36767,\n\t};\n\n\tconstructor(simUI: IndividualSimUI<any>) {\n\t\tthis.player = simUI.player;\n\t\tthis.sim = simUI.sim;\n\n\t\t// Initialize empty arrays of gem priorities for each socket color\n\t\tthis.gemPriorityByColor = {} as Record<GemColor, Array<GemCapsData>>;\n\t\t\n\t\tfor (var gemColor of GemOptimizer.allGemColors) {\n\t\t\tthis.gemPriorityByColor[gemColor] = new Array<GemCapsData>();\n\t\t}\n\n\t\tthis.jcUpgradePriority = new Array<GemCapsData>();\t\n\n\t\tsimUI.addAction('Suggest Gems', 'suggest-gems-action', async () => {\n\t\t\tthis.optimizeGems();\n\t\t});\n\t}\n\n\tasync optimizeGems() {\n\t\t// First, clear all existing gems\n\t\tlet optimizedGear = this.player.getGear().withoutGems();\n\t\tthis.numSocketedJcGems = 0;\n\n\t\t// Store relevant player attributes for use in optimizations\n\t\tthis.epWeights = this.player.getEpWeights();\n\t\tthis.useJcGems = this.player.hasProfession(Profession.Jewelcrafting);\n\t\tthis.isBlacksmithing = this.player.isBlacksmithing();\n\n\t\t/*\n\t\t * Use subclass-specific logic to rank order gems of each color by value\n\t\t * and calculate the associated stat caps for each gem (when applicable).\n\t\t */\n\t\tconst ungemmedStats = await this.updateGear(optimizedGear);\n\t\tthis.updateGemPriority(optimizedGear, ungemmedStats);\n\n\t\t// Next, socket and activate the meta\n\t\toptimizedGear = optimizedGear.withMetaGem(this.sim.db.lookupGem(this.metaGemID));\n\t\toptimizedGear = this.activateMetaGem(optimizedGear);\n\t\tawait this.updateGear(optimizedGear);\n\n\t\t// Now loop through all gem colors where a priority list has been defined\n\t\tfor (var gemColor of GemOptimizer.allGemColors) {\n\t\t\tif (this.gemPriorityByColor[gemColor].length > 0) {\n\t\t\t\toptimizedGear = await this.fillGemsByColor(optimizedGear, gemColor);\n\t\t\t}\n\t\t}\n\n\t\t// Finally, substitute JC gems by priority while respecting stat caps\n\t\tif (this.useJcGems) {\n\t\t\toptimizedGear = await this.substituteJcGems(optimizedGear);\n\t\t}\n\t}\n\t\n\tasync updateGear(gear: Gear): Promise<Stats> {\n\t\tthis.player.setGear(TypedEvent.nextEventID(), gear);\n\t\tawait this.sim.updateCharacterStats(TypedEvent.nextEventID());\n\t\treturn Stats.fromProto(this.player.getCurrentStats().finalStats);\n\t}\n\n\t/**\n\t * Helper method for meta gem activation.\n\t *\n\t * @remarks\n\t * Based on the ansatz that most specs are forced to use a suboptimal gem color in\n\t * order to statisfy their meta requirements. As a result, it is helpful to\n\t * compute the item slot in a gear set that provides the strongest socket bonus \n\t * for that color, since this should minimize the \"cost\" of activation.\n\t *\n\t * @param gear - Ungemmed gear set\n\t * @param color - Socket color used for meta gem activation\n\t * @param singleOnly - If true, exclude items containing more than one socket of the specified color. If false, instead normalize the socket bonus by the number of such sockets.\n\t * @param blacklistedColor - If non-null, exclude items containing any sockets of this color (assumed to be different from the color used for activation).\n\t * @returns Optimal item slot for activation under the specified constraints, or null if not found.\n\t */\t\n\tfindStrongestSocketBonus(gear: Gear, color: GemColor, singleOnly: boolean, blacklistedColor: GemColor | null): ItemSlot | null {\n\t\tlet optimalSlot: ItemSlot | null = null;\n\t\tlet maxSocketBonusEP: number = 1e-8;\n\n\t\tfor (var slot of gear.getItemSlots()) {\n\t\t\tconst item = gear.getEquippedItem(slot);\n\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (item.numSocketsOfColor(blacklistedColor) != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst numSockets = item.numSocketsOfColor(color);\n\n\t\t\tif ((numSockets == 0) || (singleOnly && (numSockets != 1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst socketBonusEP = new Stats(item.item.socketBonus).computeEP(this.epWeights);\n\t\t\tconst normalizedEP = socketBonusEP / numSockets;\n\n\t\t\tif (normalizedEP > maxSocketBonusEP) {\n\t\t\t\toptimalSlot = slot;\n\t\t\t\tmaxSocketBonusEP = normalizedEP;\n\t\t\t}\n\t\t}\n\n\t\treturn optimalSlot;\n\t}\n\t\n\tsocketGemInFirstMatchingSocket(gear: Gear, itemSlot: ItemSlot | null, colorToMatch: GemColor, gemId: number): Gear {\n\t\tif (itemSlot != null) {\n\t\t\tconst item = gear.getEquippedItem(itemSlot);\n\n\t\t\tif (!item) {\n\t\t\t\treturn gear;\n\t\t\t}\n\n\t\t\tfor (const [socketIdx, socketColor] of item!.allSocketColors().entries()) {\n\t\t\t\tif (socketColor == colorToMatch) {\n\t\t\t\t\treturn gear.withEquippedItem(itemSlot, item!.withGem(this.sim.db.lookupGem(gemId), socketIdx), true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn gear;\n\t}\n\n\tasync fillGemsByColor(gear: Gear, color: GemColor): Promise<Gear> {\n\t\tconst socketList = this.findSocketsByColor(gear, color);\n\t\treturn await this.fillGemsToCaps(gear, socketList, this.gemPriorityByColor[color], 0, 0);\n\t}\n\t\n\t/**\n\t * Shared wrapper for compiling eligible sockets for each gem priority list.\n\t *\n\t * @remarks\n\t * Subclasses are required to implement the allowGemInSocket method, which\n\t * contains the (spec-specific) logic on when to match socket bonuses etc.\n\t *\n\t * @param gear - Partially gemmed gear set\n\t * @param color - Color associated with a single gem priority list\n\t * @returns Array of sockets that will be filled using the priority list associated with the specified color.\n\t */\t\n\tfindSocketsByColor(gear: Gear, color: GemColor): Array<SocketData> {\n\t\tconst socketList = new Array<SocketData>();\n\n\t\tfor (var slot of gear.getItemSlots()) {\n\t\t\tconst item = gear.getEquippedItem(slot);\n\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const [socketIdx, socketColor] of item.curSocketColors(this.isBlacksmithing).entries()) {\n\t\t\t\tif (item!.hasSocketedGem(socketIdx)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (this.allowGemInSocket(color, socketColor, slot, item)) {\n\t\t\t\t\tsocketList.push({ itemSlot: slot, socketIdx: socketIdx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn socketList;\n\t}\n\n\tasync substituteJcGems(gear: Gear): Promise<Gear> {\n\t\tlet updatedGear: Gear = gear;\n\t\tlet gemIdx = 0;\n\n\t\twhile ((this.numSocketedJcGems < 3) && (gemIdx < this.jcUpgradePriority.length)) {\n\t\t\tconst gemData = this.jcUpgradePriority[gemIdx];\n\t\t\tconst baseGem = this.sim.db.lookupGem(gemData.gemId);\n\n\t\t\tif (!updatedGear.getAllGems(this.isBlacksmithing).includes(baseGem!)) {\n\t\t\t\tgemIdx += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst upgradedGem = this.sim.db.lookupGem(GemOptimizer.jcUpgradesById[gemData.gemId]);\n\t\t\tconst testGear = updatedGear.withSingleGemSubstitution(baseGem, upgradedGem, this.isBlacksmithing);\n\t\t\tconst newStats = await this.updateGear(testGear);\n\n\t\t\tif (newStats.belowCaps(gemData.statCaps)) {\n\t\t\t\tupdatedGear = testGear;\n\t\t\t\tthis.numSocketedJcGems += 1;\n\t\t\t} else {\n\t\t\t\tawait this.updateGear(updatedGear);\n\t\t\t\tgemIdx += 1;\n\t\t\t}\t\n\t\t}\n\n\t\treturn updatedGear;\n\t}\n\t\n\tasync fillGemsToCaps(gear: Gear, socketList: Array<SocketData>, gemCaps: Array<GemCapsData>, numPasses: number, firstIdx: number): Promise<Gear> {\n\t\tlet updatedGear: Gear = gear;\n\t\tconst currentGem = this.sim.db.lookupGem(gemCaps[numPasses].gemId);\n\n\t\t// On the first pass, we simply fill all sockets with the highest priority gem\n\t\tif (numPasses == 0) {\n\t\t\tfor (var socketData of socketList.slice(firstIdx)) {\n\t\t\t\tupdatedGear = updatedGear.withGem(socketData.itemSlot, socketData.socketIdx, currentGem);\n\t\t\t}\n\t\t}\n\n\t\t// If we are below the relevant stat cap for the gem we just filled on the last pass, then we are finished.\n\t\tlet newStats = await this.updateGear(updatedGear);\n\t\tconst currentCap = gemCaps[numPasses].statCaps;\n\n\t\tif (newStats.belowCaps(currentCap) || (numPasses == gemCaps.length - 1)) {\n\t\t\treturn updatedGear;\n\t\t}\n\n\t\t// If we exceeded the stat cap, then work backwards through the socket list and replace each gem with the next highest priority option until we are below the cap\n\t\tconst nextGem = this.sim.db.lookupGem(gemCaps[numPasses + 1].gemId);\n\t\tconst nextCap = gemCaps[numPasses + 1].statCaps;\n\t\tlet capForReplacement = currentCap.subtract(nextCap);\n\n\t\tif (currentCap.computeEP(capForReplacement) <= 0) {\n\t\t\tcapForReplacement = currentCap;\n\t\t}\n\n\t\tfor (var idx = socketList.length - 1; idx >= firstIdx; idx--) {\n\t\t\tif (newStats.belowCaps(capForReplacement)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tupdatedGear = updatedGear.withGem(socketList[idx].itemSlot, socketList[idx].socketIdx, nextGem);\n\t\t\tnewStats = await this.updateGear(updatedGear);\n\t\t}\n\n\t\t// Now run a new pass to check whether we've exceeded the next stat cap\n\t\tlet nextIdx = idx + 1;\n\n\t\tif (!newStats.belowCaps(currentCap)) {\n\t\t\tnextIdx = firstIdx;\n\t\t}\n\n\t\treturn await this.fillGemsToCaps(updatedGear, socketList, gemCaps, numPasses + 1, nextIdx);\n\t}\n\n\tabstract activateMetaGem(gear: Gear): Gear;\n\n\tabstract updateGemPriority(ungemmedGear: Gear, passiveStats: Stats): void;\n\n\tabstract allowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean;\n}\n\nexport class PhysicalDPSGemOptimizer extends GemOptimizer {\n\tmetaGemID: number = 41398; // Relentless Earthsiege Diamond\n\tarpSlop: number = 11;\n\texpSlop: number = 4;\n\thitSlop: number = 4;\n\tuseArpGems: boolean;\n\tuseExpGems: boolean;\n\tuseAgiGems: boolean;\n\tuseStrGems: boolean;\n\tarpTarget!: number;\n\tpassiveArp!: number;\n\tarpStackDetected!: boolean;\n\ttearSlot!: ItemSlot | null;\n\n\tconstructor(simUI: IndividualSimUI<any>, useArpGems: boolean, useExpGems: boolean, useAgiGems: boolean, useStrGems: boolean) {\n\t\tsuper(simUI);\n\t\tthis.useArpGems = useArpGems;\n\t\tthis.useExpGems = useExpGems;\n\t\tthis.useAgiGems = useAgiGems;\n\t\tthis.useStrGems = useStrGems;\n\t}\n\n\tupdateGemPriority(ungemmedGear: Gear, passiveStats: Stats) {\n\t\t// First calculate any gear-dependent stat caps.\n\t\tthis.arpTarget = this.calcArpTarget(ungemmedGear);\n\t\tconst arpCap = new Stats().withStat(Stat.StatArmorPenetration, this.arpTarget + this.arpSlop);\n\t\tconst critCap = this.calcCritCap(ungemmedGear);\n\t\tconst expCap = new Stats().withStat(Stat.StatExpertise, this.calcExpTarget() + this.expSlop);\n\t\tconst hitCap = new Stats().withStat(Stat.StatMeleeHit, 8. * 32.79 + this.hitSlop);\n\n\t\t// Reset optimal Tear slot from prior calculations\n\t\tthis.tearSlot = null;\n\t\t\n\t\t/*\n\t\t * For specs that gem ArP, determine whether the current gear\n\t\t * configuration will optimally hard stack Fractured gems or not.\n\t\t */\n\t\tthis.passiveArp = passiveStats.getStat(Stat.StatArmorPenetration);\n\t\tthis.arpStackDetected = this.detectArpStackConfiguration(ungemmedGear);\n\n\t\t// Update red gem priority\n\t\tconst redGemCaps = new Array<GemCapsData>();\n\n\t\t// Fractured Cardinal Ruby\n\t\tif (this.useArpGems) {\n\t\t\tredGemCaps.push({ gemId: 40117, statCaps: arpCap });\n\t\t}\n\n\t\t// Precise Cardinal Ruby\n\t\tif (this.useExpGems) {\n\t\t\tredGemCaps.push({ gemId: 40118, statCaps: expCap });\n\t\t}\n\n\t\t// Delicate Cardinal Ruby\n\t\tif (this.useAgiGems) {\n\t\t\tredGemCaps.push({ gemId: 40112, statCaps: critCap });\n\t\t}\n\n\t\t// Bold Cardinal Ruby\n\t\tif (this.useStrGems) {\n\t\t\tredGemCaps.push({ gemId: 40111, statCaps: new Stats() });\n\t\t}\n\n\t\tthis.gemPriorityByColor[GemColor.GemColorRed] = redGemCaps;\n\n\t\t// Update yellow gem priority\n\t\tconst yellowGemCaps = new Array<GemCapsData>();\n\n\t\t// Accurate Ametrine\n\t\tif (this.useExpGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40162, statCaps: hitCap.add(expCap) });\n\t\t}\n\n\t\t// Rigid Ametrine\n\t\tyellowGemCaps.push({ gemId: 40125, statCaps: hitCap });\n\n\t\t// Fractured Cardinal Ruby\n\t\tif (this.arpStackDetected) {\n\t\t\tyellowGemCaps.push({ gemId: 40117, statCaps: arpCap });\n\t\t}\n\t\t\n\t\t// Accurate Ametrine (needed to add twice to catch some edge cases)\n\t\tif (this.useExpGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40162, statCaps: hitCap.add(expCap) });\n\t\t}\n\n\t\t// Glinting Ametrine\n\t\tif (this.useAgiGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40148, statCaps: hitCap.add(critCap) });\n\t\t}\n\n\t\t// Etched Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40143, statCaps: hitCap });\n\t\t}\n\n\t\t// Deadly Ametrine\n\t\tif (this.useAgiGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40147, statCaps: critCap });\n\t\t}\n\n\t\t// Inscribed Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40142, statCaps: critCap });\n\t\t}\n\n\t\t// Fierce Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40146, statCaps: new Stats() });\n\t\t}\n\t\t\n\t\tthis.gemPriorityByColor[GemColor.GemColorYellow] = yellowGemCaps;\n\n\t\t// Update JC upgrade priority\n\t\tthis.jcUpgradePriority = new Array<GemCapsData>();\n\t\t\n\t\tif (this.useExpGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40118, statCaps: expCap });\n\t\t}\n\t\t\n\t\tthis.jcUpgradePriority.push({ gemId: 40125, statCaps: hitCap });\n\t\t\n\t\tif (this.useAgiGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40112, statCaps: critCap });\n\t\t}\n\n\t\tif (this.useStrGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40111, statCaps: new Stats() });\n\t\t}\n\t}\n\n\tdetectArpStackConfiguration(ungemmedGear: Gear): boolean {\n\t\tif (!this.useArpGems) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * Generate a \"dummy\" list of red sockets in order to determine whether\n\t\t * ignoring yellow socket bonuses to stack more ArP gems will be correct.\n\t\t * Subtract 2 from the length of this list to account for meta gem +\n\t\t * Nightmare Tear.\n\t\t */\n\t\tconst dummyRedSocketList = this.findSocketsByColor(ungemmedGear, GemColor.GemColorRed);\n\t\tconst numRedSockets = dummyRedSocketList.length - 2;\n\t\tlet projectedArp = this.passiveArp + 20 * numRedSockets;\n\n\t\tif (this.useJcGems) {\n\t\t\tprojectedArp += 42;\n\t\t}\n\n\t\treturn (this.arpTarget > 1000) && (projectedArp > 648) && (projectedArp + 20 < this.arpTarget + this.arpSlop);\t\n\t}\n\n\tactivateMetaGem(gear: Gear): Gear {\n\t\t/*\n\t\t * Use a single Nightmare Tear for meta activation. Prioritize blue\n\t\t * sockets for it if possible, and fall back to yellow sockets if not.\n\t\t */\n\t\tlet tearColor = GemColor.GemColorBlue;\n\t\tthis.tearSlot = this.findBlueTearSlot(gear);\n\n\t\tif (this.tearSlot == null) {\n\t\t\ttearColor = GemColor.GemColorYellow;\n\t\t\tthis.tearSlot = this.findYellowTearSlot(gear);\n\t\t}\n\n\t\treturn this.socketTear(gear, tearColor);\n\t}\n\t\n\tsocketTear(gear: Gear, tearColor: GemColor): Gear {\n\t\treturn this.socketGemInFirstMatchingSocket(gear, this.tearSlot, tearColor, 49110);\n\t}\n\t\n\tfindBlueTearSlot(gear: Gear): ItemSlot | null {\n\t\t// Eligible Tear slots have only one blue socket max.\n\t\tconst singleOnly = true;\n\n\t\t/*\n\t\t * Additionally, for hard ArP stack configurations, only use blue sockets\n\t\t * for Tear if there are no yellow sockets in that item slot, since hard\n\t\t * ArP stacks ignore yellow socket bonuses in favor of stacking more\n\t\t * Fractured gems.\n\t\t */\n\t\tconst blacklistedColor = this.arpStackDetected ? GemColor.GemColorYellow : null;\n\n\t\treturn this.findStrongestSocketBonus(gear, GemColor.GemColorBlue, singleOnly, blacklistedColor);\n\t}\n\n\tfindYellowTearSlot(gear: Gear): ItemSlot | null {\n\t\treturn this.findStrongestSocketBonus(gear, GemColor.GemColorYellow, false, GemColor.GemColorBlue);\n\t}\n\t\n\tallowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean {\n\t\tconst ignoreYellowSockets = ((item!.numSocketsOfColor(GemColor.GemColorBlue) > 0) && (itemSlot != this.tearSlot));\n\t\tlet matchYellowSocket = false;\n\t\t\n\t\tif ((socketColor == GemColor.GemColorYellow) && !ignoreYellowSockets) {\n\t\t\tmatchYellowSocket = new Stats(item.item.socketBonus).computeEP(this.epWeights) > 1e-8;\n\t\t}\n\n\t\treturn ((gemColor == GemColor.GemColorYellow) && matchYellowSocket) || ((gemColor == GemColor.GemColorRed) && !matchYellowSocket);\n\t}\n\t\n\tfindSocketsByColor(gear: Gear, color: GemColor): Array<SocketData> {\n\t\tconst socketList = super.findSocketsByColor(gear, color);\n\n\t\tif (this.arpStackDetected && (color == GemColor.GemColorYellow)) {\n\t\t\tthis.sortYellowSockets(gear, socketList);\n\t\t}\n\n\t\treturn socketList;\n\t}\n\t\n\tsortYellowSockets(gear: Gear, yellowSocketList: Array<SocketData>) {\n\t\tyellowSocketList.sort((a,b) => {\n\t\t\t// If both yellow sockets belong to the same item, then treat them equally.\n\t\t\tconst slot1 = a.itemSlot;\n\t\t\tconst slot2 = b.itemSlot;\n\n\t\t\tif (slot1 == slot2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// If an item already has a Nightmare Tear socketed, then bump up any yellow sockets in it to highest priority.\n\t\t\tif (slot1 == this.tearSlot) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (slot2 == this.tearSlot) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// For all other cases, sort by the ratio of the socket bonus value divided by the number of yellow sockets required to activate it.\n\t\t\tconst item1 = gear.getEquippedItem(slot1);\n\t\t\tconst bonus1 = new Stats(item1!.item.socketBonus).computeEP(this.epWeights);\n\t\t\tconst item2 = gear.getEquippedItem(slot2);\n\t\t\tconst bonus2 = new Stats(item2!.item.socketBonus).computeEP(this.epWeights);\n\t\t\treturn bonus2 / item2!.numSocketsOfColor(GemColor.GemColorYellow) - bonus1 / item1!.numSocketsOfColor(GemColor.GemColorYellow);\n\t\t});\n\t}\n\t\n\tcalcArpTarget(gear: Gear): number {\n\t\tlet arpTarget = 1399;\n\n\t\t/*\n\t\t * First handle ArP proc trinkets. If more than one of these are equipped\n\t\t * simultaneously, it is assumed that the user is desyncing them via ICD\n\t\t * resets, such that the soft cap is set by the strongest proc.\n\t\t */\n\t\tif (gear.hasTrinket(45931)) {\n\t\t\tarpTarget -= 751; // Mjolnir Runestone\n\t\t} else if (gear.hasTrinket(50198)) {\n\t\t\tarpTarget -= 678; // Needle-Encrusted Scorpion\n\t\t} else if (gear.hasTrinket(40256)) {\n\t\t\tarpTarget -= 612; // Grim Toll\n\t\t}\n\n\t\t// Then check for Executioner enchant\n\t\tconst weapon = gear.getEquippedItem(ItemSlot.ItemSlotMainHand);\n\n\t\tif (weapon?.enchant?.effectId == 3225) {\n\t\t\tarpTarget -= 120;\n\t\t}\n\n\t\treturn arpTarget;\n\t}\n\n\tcalcExpTarget(): number {\n\t\treturn 6.5 * 32.79;\n\t}\n\t\n\tcalcCritCap(gear: Gear): Stats {\n\t\t/*\n\t\t * Only some specs incorporate Crit soft caps into their gemming logic, so\n\t\t * the parent method here simply returns an empty Stats object (meaning\n\t\t * that Crit cap will just be ignored elsewhere in the code). Custom\n\t\t * spec-specific subclasses can override this as desired.\n\t\t */\n\t\treturn new Stats();\n\t}\n\t\n\tasync fillGemsByColor(gear: Gear, color: GemColor): Promise<Gear> {\n\t\t/*\n\t\t * Parent logic substitutes JC gems after filling normal gems first, but\n\t\t * for specs that gem ArP, it is more optimal to pre-fill some Fractured\n\t\t * Dragon's Eyes if doing so gets us closer to the target.\n\t\t */\n\t\tlet updatedGear: Gear = gear;\n\n\t\tif ((color == GemColor.GemColorRed) && this.useArpGems && this.useJcGems) {\n\t\t\tupdatedGear = this.optimizeJcArpGems(updatedGear);\n\t\t}\n\n\t\treturn await super.fillGemsByColor(updatedGear, color);\n\t}\n\n\tcalcDistanceToArpTarget(numJcArpGems: number, numRedSockets: number): number {\n\t\tconst numNormalArpGems = Math.max(0, Math.min(numRedSockets - 3, Math.floor((this.arpTarget + this.arpSlop - this.passiveArp - 34 * numJcArpGems) / 20)));\n\t\tconst projectedArp = this.passiveArp + 34 * numJcArpGems + 20 * numNormalArpGems;\n\t\treturn Math.abs(projectedArp - this.arpTarget);\n\t}\n\n\toptimizeJcArpGems(gear: Gear): Gear {\n\t\t// First determine how many of the JC gems should be 34 ArP gems\n\t\tconst redSocketList = this.findSocketsByColor(gear, GemColor.GemColorRed);\n\t\tconst numRedSockets = redSocketList.length;\n\t\tlet optimalJcArpGems = [0,1,2,3].reduce((m,x)=> this.calcDistanceToArpTarget(m, numRedSockets)<this.calcDistanceToArpTarget(x, numRedSockets) ? m:x);\n\t\toptimalJcArpGems = Math.min(optimalJcArpGems, numRedSockets);\n\n\t\t// Now socket just those gems, saving other JC substitutions for later\n\t\tlet updatedGear: Gear = gear;\n\n\t\tfor (let i = 0; i < optimalJcArpGems; i++) {\n\t\t\tupdatedGear = updatedGear.withGem(redSocketList[i].itemSlot, redSocketList[i].socketIdx, this.sim.db.lookupGem(42153));\n\t\t}\n\n\t\tthis.numSocketedJcGems = optimalJcArpGems;\n\t\treturn updatedGear;\n\t}\n}\n\nexport class TankGemOptimizer extends GemOptimizer {\n\tmetaGemID: number = 41380; // Austere Earthsiege Diamond\n\t\n\tupdateGemPriority(ungemmedGear: Gear, passiveStats: Stats) {\n\t\t// Base class just stuffs pure Stamina gems everywhere\n\t\tconst blueGemCaps = new Array<GemCapsData>();\n\t\tblueGemCaps.push({ gemId: 40119, statCaps: new Stats() });\n\t\tthis.gemPriorityByColor[GemColor.GemColorBlue] = blueGemCaps;\n\t\tthis.jcUpgradePriority = blueGemCaps;\n\t}\n\t\n\tactivateMetaGem(gear: Gear): Gear {\n\t\t/*\n\t\t * Use a single Shifting Dreadstone gem for meta activation, in the slot\n\t\t * with the strongest bonus for a single red socket.\n\t\t */\n\t\treturn this.socketGemInFirstMatchingSocket(gear, this.findStrongestSocketBonus(gear, GemColor.GemColorRed, true, GemColor.GemColorYellow), GemColor.GemColorRed, 40130);\n\t}\n\t\n\tallowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean {\n\t\treturn gemColor == GemColor.GemColorBlue;\n\t}\n}\n"],"names":["_GemOptimizer","constructor","simUI","gemColor","__publicField","this","player","sim","gemPriorityByColor","allGemColors","Array","jcUpgradePriority","addAction","async","optimizeGems","optimizedGear","getGear","withoutGems","numSocketedJcGems","epWeights","getEpWeights","useJcGems","hasProfession","Profession","Jewelcrafting","isBlacksmithing","ungemmedStats","updateGear","updateGemPriority","withMetaGem","db","lookupGem","metaGemID","activateMetaGem","length","fillGemsByColor","substituteJcGems","gear","setGear","TypedEvent","nextEventID","updateCharacterStats","Stats","fromProto","getCurrentStats","finalStats","findStrongestSocketBonus","color","singleOnly","blacklistedColor","optimalSlot","maxSocketBonusEP","slot","getItemSlots","item","getEquippedItem","numSocketsOfColor","numSockets","normalizedEP","socketBonus","computeEP","socketGemInFirstMatchingSocket","itemSlot","colorToMatch","gemId","socketIdx","socketColor","allSocketColors","entries","withEquippedItem","withGem","socketList","findSocketsByColor","fillGemsToCaps","curSocketColors","hasSocketedGem","allowGemInSocket","push","updatedGear","gemIdx","gemData","baseGem","getAllGems","includes","upgradedGem","jcUpgradesById","testGear","withSingleGemSubstitution","belowCaps","statCaps","gemCaps","numPasses","firstIdx","currentGem","socketData","slice","newStats","currentCap","nextGem","nextCap","capForReplacement","subtract","idx","nextIdx","GemOptimizer","GemColor","GemColorRed","GemColorYellow","GemColorBlue","PhysicalDPSGemOptimizer","useArpGems","useExpGems","useAgiGems","useStrGems","super","ungemmedGear","passiveStats","arpTarget","calcArpTarget","arpCap","withStat","Stat","StatArmorPenetration","arpSlop","critCap","calcCritCap","expCap","StatExpertise","calcExpTarget","expSlop","hitCap","StatMeleeHit","hitSlop","tearSlot","passiveArp","getStat","arpStackDetected","detectArpStackConfiguration","redGemCaps","yellowGemCaps","add","numRedSockets","projectedArp","tearColor","findBlueTearSlot","findYellowTearSlot","socketTear","ignoreYellowSockets","matchYellowSocket","sortYellowSockets","yellowSocketList","sort","a","b","slot1","slot2","item1","bonus1","item2","hasTrinket","weapon","ItemSlot","ItemSlotMainHand","enchant","effectId","optimizeJcArpGems","calcDistanceToArpTarget","numJcArpGems","numNormalArpGems","Math","max","min","floor","abs","redSocketList","optimalJcArpGems","reduce","m","x","i","TankGemOptimizer","arguments","blueGemCaps"],"mappings":"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"}